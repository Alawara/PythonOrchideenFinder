import requests
import pandas 


def Suchgebiet(lat, lon, toleranz =0.1):
    # toleranz ~ entspricht ca. 10 km (je nach Breitengrad)
    min_lat = lat - toleranz
    max_lat = lat + toleranz
    min_lon = lon - toleranz
    max_lon = lon + toleranz
    return f"POLYGON(({min_lon} {min_lat}, {min_lon} {max_lat}, {max_lon} {max_lat}, {max_lon} {min_lat}, {min_lon} {min_lat}))"


def hole_Orchideen(lat, lon, radius_meter =100, limit=10):
    url = "https://api.gbif.org/v1/occurrence/search"
    geometry = Suchgebiet(lat, lon, toleranz=0.9)  # ~20 km
    parameter = {
        "taxonKey": 7689,  # TaxonKey steht in der adresszeile wenn man die Pflanze in GBIF sucht. Gentiana ist 2503,
        "hasCoordinate": "true",
        "lat": lat,
        "lon": lon,
        "radius": radius_meter,  
        "limit": limit,
        "geometry": geometry
        #"country": "DE"    # ohne diesen Zusatz kam ich irgendwo in Schweden raus. Er scheint aber auch allgemein die Koordinaten nicht zu benutzen. 
       # Laut ChatGPT geht das mit den Koordinaten nicht, man muss eine "Box" definieren, innerhalb derer gesucht wird, und das als "geometry" übergeben.  
    }
    response = requests.get(url, params=parameter)

    

    data = response.json()["results"]
    
    print("[GBIF URL]:", response.url)

    records = []   # Wir erstellen eine leere Liste und fügen bei jedem Suchergebnis die Attribute, die uns interessieren hinzu. 
    for item in data:
        records.append({
            "species": item.get("species"),
            "scientificName": item.get("scientificName"),
            "eventDate": item.get("eventDate"),
            "decimalLatitude": item.get("decimalLatitude"),
            "decimalLongitude": item.get("decimalLongitude"),
            "locality": item.get("locality"),
            "Rechteinhaberin": item.get("rightsHolder"),
            "Höhe ü. d. M.": item.get("elevation")
        })
    print(f"[Koordinaten erhalten] lat={lat}, lon={lon}")

    









    return pandas.DataFrame(records)

# Koordinaten muss man von Hand eingeben. Die Kombination mit der Funktion, die das Suchfenster für GBIF erzeugt, habe ich noch nicht hinbekommen. 
#ergebnis = hole_Orchideen(lat=46.5354, lon=7.95)
ergebnis = hole_Orchideen(lat=46.68, lon=7.8646) # Koordinaten von Interlaken, Schweiz
#ergebnis = hole_Orchideen(lat=-4.2, lon=-69.94) # Koordinaten Leticia, Kolumbien, da gibt es eine Fehlermeldung, ich vermute es liegt an der API


print(ergebnis.head(30))  # Die zahl spezifiziert die Anzahl der Ausgaben. Defaultwert ist 5. 





import mysql.connector

# DB-Verbindung
connection = mysql.connector.connect(
    host="localhost",
    user="root",
    port="3308",
    passwd="1Diana?!",
    database="plants",
    charset="utf8mb3"
)

cursor = connection.cursor()

# Tabelle erstellen (falls noch nicht vorhanden)
create_table_query = """
CREATE TABLE IF NOT EXISTS orchids_3 (
    orchid_id INT AUTO_INCREMENT PRIMARY KEY,
    species VARCHAR(128),
    scientificName VARCHAR(128),
    eventDate VARCHAR(64),
    decimalLatitude FLOAT,
    decimalLongitude FLOAT,
    locality TEXT,
    rightsHolder TEXT,
    elevation FLOAT
);
"""
cursor.execute(create_table_query)

# Daten aus dem DataFrame einfügen
insert_query = """
INSERT INTO orchids_3 
(species, scientificName, eventDate, decimalLatitude, decimalLongitude, locality, rightsHolder, elevation)
VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
"""

for _, row in ergebnis.iterrows():
    values = (
        row["species"],
        row["scientificName"],
        row["eventDate"],
        row["decimalLatitude"],
        row["decimalLongitude"],
        row["locality"],
        row["Rechteinhaberin"],
        row["Höhe ü. d. M."]
    )
    cursor.execute(insert_query, values)

# Änderungen speichern und Verbindung schließen
connection.commit()
cursor.close()
connection.close()

